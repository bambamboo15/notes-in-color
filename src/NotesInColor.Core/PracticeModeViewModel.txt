/**
 *                    Notes in Color
 *            A project by Benyamin Bamburac
 * 
 * This project is a modern MIDI file player and visualizer
 * with some MIDI controller support.
 */

using CommunityToolkit.Mvvm.ComponentModel;
using NotesInColor.Core;
using NotesInColor.Services;
using System.Diagnostics;

namespace NotesInColor.ViewModel;

/**
 * Viewmodel that is entirely dedicated to practice mode. I tried to make this really detailed and understandable,
 * because I like neat code.
 */
public partial class PracticeModeViewModel : ObservableObject {
    /**
     * Determines the type of feedback that is sent.
     */
    public enum FeedbackType {
        Perfect,
        Miss
    };

    /**
     * This event is triggered every time visual feedback (such as PERFECT, MISS, etc.)
     * is displayed on the screen in response to player input during practice mode.
     */
    public delegate void FeedbackDelegate(FeedbackType feedbackType);
    public event FeedbackDelegate? Feedback;

    private readonly IInputDeviceManager InputDeviceManager;
    private readonly MIDIPlaythroughData MIDIPlaythroughData;

    private int[] StartIndices = new int[128];  /* lowest index of note considered for assessment of player input, for each key */
    private int[] EndIndices = new int[128];    /* highest index of note considered for assessment of player input, for each key */
    private long Variability = 500000;          /* the maximum allowed variability in microseconds */

    public PracticeModeViewModel(IInputDeviceManager InputDeviceManager, MIDIPlaythroughData MIDIPlaythroughData) {
        this.InputDeviceManager = InputDeviceManager;
        this.MIDIPlaythroughData = MIDIPlaythroughData;

        this.InputDeviceManager.InputMessageReceived += OnInputMessageRecieved;
        this.MIDIPlaythroughData.OnLoaded += OnLoaded;
    }

    /**
     * This method is triggered when an input message is recieved from an input device.
     */
    private void OnInputMessageRecieved(object? sender, MIDIInputMessageArgs args) {
        if (!MIDIPlaythroughData.PracticeMode)
            return;

        if (args.Message is MIDIInputNoteOnMessage) {
            Debug.WriteLine("note on");
        } else if (args.Message is MIDIInputNoteOffMessage) {
            Debug.WriteLine("note off");
        }
    }

    /**
     * This method is triggered when a composition is loaded.
     */
    private void OnLoaded() {
        if (!MIDIPlaythroughData.PracticeMode)
            return;

        // Determine the inclusive [StartIndex, EndIndex] range of notes for each key,
        // where all notes are within the time window [0, Variability], and both range
        // endpoints belong to the current key.
        for (int key = 0; key < 128; ++key) {
            ref int StartIndex = ref StartIndices[key], EndIndex = ref EndIndices[key];

            for (StartIndex = 0; StartIndex < MIDIPlaythroughData.Notes.Length &&
                MIDIPlaythroughData.Notes[StartIndex].NoteNumber != key; ++StartIndex) ;

            EndIndex = StartIndex;
            for (int endIndex = StartIndex; endIndex < MIDIPlaythroughData.Notes.Length &&
                        MIDIPlaythroughData.Notes[endIndex].Time <= Variability; ++endIndex)
                if (MIDIPlaythroughData.Notes[EndIndex].NoteNumber == key)
                    EndIndex = endIndex;
        }
    }

    /**
     * This function provides a utility that should be called via polling that is essentially
     * a discrete time step of determining feedback quite similarly to how a rhythm game works;
     * it determines hit/miss and other feedback based on the player's actions and dynamic
     * properties such as the timing of the notes. This only runs when practice mode
     * is enabled; otherwise, it does nothing.
     */
    public void AssessPlayerInput() {
        if (!MIDIPlaythroughData.PracticeMode)
            return;

        for (int key = 0; key < 128; ++key) {
            ref int StartIndex = ref StartIndices[key], EndIndex = ref EndIndices[key];

            // Move forward the range of notes considered for player input assessment, from the bottommost note.
            // This ensures that only notes whose end time is greater than the current time minus the variability
            // window are considered.
            while (StartIndex < MIDIPlaythroughData.Notes.Length &&
                    MIDIPlaythroughData.Notes[StartIndex].EndTime <= MIDIPlaythroughData.CurrentMicroseconds - Variability)
                ++StartIndex;

            // Move the start of range forward until the note is of the key.
            while (StartIndex < MIDIPlaythroughData.Notes.Length &&
                    MIDIPlaythroughData.Notes[StartIndex].NoteNumber != key)
                ++StartIndex;

            // Move forward the range of notes considered for player input assessment, from the topmost note.
            // This ensures that only notes whose end time is greater than the current time plus the variability
            // window are considered.
            while (EndIndex < MIDIPlaythroughData.Notes.Length &&
                    MIDIPlaythroughData.Notes[EndIndex].Time <= MIDIPlaythroughData.CurrentMicroseconds + Variability)
                ++EndIndex;

            // Move the end of range backward until the note is of the key.
            while (EndIndex > 0 &&
                    MIDIPlaythroughData.Notes[EndIndex - 1].NoteNumber != key)
                --EndIndex;
        }

        AssessPlayerInputImplementation();
    }

    /**
     * The internal unchecked implementation of AssessPlayerInput which goes straight into the core logic.
     */
    private void AssessPlayerInputImplementation() {
        for (int key = 0; key < 128; ++key) {
            Feedback?.Invoke(FeedbackType.Perfect);
        }
    }
}